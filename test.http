@base = http://localhost:8080/api
@svc = TESTE-API
@host = pod-2
@msg = [TEST_HTTP] RedisCommandTimeoutException: Command timed out after 500ms.
@stack =

### 0) logHash 계산 (옵션)
POST {{base}}/test/hash
Content-Type: application/json

{
  "serviceName": "{{svc}}",
  "message": "{{msg}}",
  "stackTrace": "{{stack}}"
}

> {%
  const b = (typeof response.body === "string") ? JSON.parse(response.body) : response.body;
  if (b.logHash) client.global.set("logHash", String(b.logHash));
%}

### 1) BEFORE CLEANUP
DELETE {{base}}/test/data/by-log-hash/{{logHash}}

### 2) 로그 enqueue (202)
POST {{base}}/logs
Content-Type: application/json

{
  "serviceName": "{{svc}}",
  "hostName": "{{host}}",
  "logLevel": "ERROR",
  "message": "{{msg}}",
  "stackTrace": "{{stack}}"
}

### 3) (옵션) 큐 강제 처리
POST {{base}}/test/queue/drain

### 4) logs 조회 + logId 확보
@keyword = %5BTEST_HTTP%5D
GET {{base}}/logs?serviceName={{svc}}&keyword={{keyword}}&size=20

> {%
  const body = (typeof response.body === "string") ? JSON.parse(response.body) : response.body;
  if (!body.content || body.content.length === 0) throw new Error("FAIL: logs empty");

  const hit = body.content.find(x => String(x.message).includes("[TEST_HTTP]"));
  if (!hit) throw new Error("FAIL: log not found");

  client.global.set("logId", String(hit.logId));
  client.global.set("logHash", String(hit.logHash));
  client.global.set("baseRepeat", String(hit.repeatCount ?? 1));
%}

### 5) Incident 확인
GET {{base}}/incidents/{{logHash}}

### 6) (선택) RESOLVED
PATCH {{base}}/logs/{{logId}}/status?newStatus=RESOLVED

### 7) Incident 재확인
GET {{base}}/incidents/{{logHash}}

### 8) IGNORE (SoT: Incident)
PATCH {{base}}/incidents/{{logHash}}/status?newStatus=IGNORED

### 9) Outbox 처리 대기
# 스케줄러 기반 → 명시적 호출 없음
# 일정 시간 대기 후 Step 10 수행

### 10) IGNORE 검증 (repeatCount 증가하면 안 됨)
POST {{base}}/logs
Content-Type: application/json

{
  "serviceName": "{{svc}}",
  "hostName": "{{host}}",
  "logLevel": "ERROR",
  "message": "{{msg}}",
  "stackTrace": "{{stack}}"
}

POST {{base}}/test/queue/drain

GET {{base}}/logs?serviceName={{svc}}&keyword=%5BTEST_HTTP%5D&size=20

> {%
  const body = (typeof response.body === "string") ? JSON.parse(response.body) : response.body;
  const hit = body.content.find(x => x.logHash === client.global.get("logHash"));

  const before = Number(client.global.get("baseRepeat"));
  const after = Number(hit.repeatCount ?? 1);

  if (after !== before) {
    throw new Error(`FAIL: repeatCount changed after IGNORE (${before} → ${after})`);
  }
%}

### 11) UNIGNORE
POST {{base}}/incidents/{{logHash}}/unignore

### 12) Outbox 처리 대기
# 스케줄러 기반 → 명시적 호출 없음
# 일정 시간 대기 후 Step 13 수행

### 13) UNIGNORE 검증 (repeatCount 증가해야 함)
POST {{base}}/logs
Content-Type: application/json

{
  "serviceName": "{{svc}}",
  "hostName": "{{host}}",
  "logLevel": "ERROR",
  "message": "{{msg}}",
  "stackTrace": "{{stack}}"
}

POST {{base}}/test/queue/drain

GET {{base}}/logs?serviceName={{svc}}&keyword=%5BTEST_HTTP%5D&size=20

> {%
  const body = (typeof response.body === "string") ? JSON.parse(response.body) : response.body;
  const hit = body.content.find(x => x.logHash === client.global.get("logHash"));

  const before = Number(client.global.get("baseRepeat"));
  const after = Number(hit.repeatCount ?? 1);

  if (after <= before) {
    throw new Error(`FAIL: repeatCount did not increase after UNIGNORE (${before} → ${after})`);
  }
%}
